vcl 4.1;

import std;
import directors;
import xkey;

# Import modules
include "includes/imports.vcl";

# Import file with probe definitions
include "includes/probes.vcl";

# Import file with backend definitions
include "includes/backends.vcl";

# Import file with acl definitions
include "includes/acls.vcl";

sub vcl_init {
    # Import file with director definitions;
    include "includes/directors.vcl";
}

sub vcl_recv {
    # https://info.varnish-software.com/blog/blog-sysadmin-monitoring-health-varnish-cache
    if (req.url == "/health") {
        return(synth(200, "health"));
    }

    # Remove tracking parameter from url and normalize query arguments
    include "includes/cache_hitrate_booster.vcl";

    set req.http.X-Varnish-Esi-Level = req.esi_level;

    # Extract real client ip from X-Forwarded-For header. We do trust X-Forwarded-For header here as it is generated by
    # nginx and any client supplied value is removed.
    if (req.http.X-Real-Ip) {
        set req.http.X-Client-Ip = req.http.X-Real-Ip;
    } elseif (req.http.X-Forwarded-For) {
        set req.http.X-Client-Ip = regsub(req.http.X-Forwarded-For, "[, ].*$", "");
    } else {
        set req.http.X-Client-Ip = client.ip;
    }

    # backend selection logic
    include "includes/backendselection.vcl";

    unset req.http.X-Restart-After-Purge;

    if (req.method == "BAN") {
        if (std.ip(req.http.X-Client-Ip, client.ip) !~ purge) {
            return (synth(405, "Method not allowed"));
        }

        set req.http.Host = regsub(req.http.host, ":\d+$", "");

        # TYPO3/Neos: Cache Tags
        if (req.http.X-Cache-Tags) {
            ban("obj.http.X-Cache-Tags ~ " + req.http.X-Cache-Tags);
            return (synth(200, "BAN Cache-Tags (" + req.http.X-Cache-Tags + ") done"));
        }

        ban("req.url ~ "+req.url);
        return (synth(200, "BAN URLs containing (" + req.url + ") done."));
    }

    # Handle PURGE
    if (req.method == "PURGE") {
        if (std.ip(req.http.X-Client-Ip, client.ip) !~ purge) {
            return (synth(403, "Forbidden"));
        }
        if (req.http.xkey) {
            set req.http.n-gone = xkey.purge(req.http.xkey);
            return (synth(200, "Invalidated " + req.http.n-gone + " objects"));
        } else {
            return (purge);
        }
    }

    if (std.healthy(req.backend_hint)) {
        set req.grace = 30s;
    } else {
        set req.grace = 24h;
    }

    # Normalize Accept-Encoding header
    # straight from the manual: https://www.varnish-cache.org/docs/3.0/tutorial/vary.html
    if (req.http.Accept-Encoding) {
        if (req.url ~ "\.(jpg|png|gif|gz|tgz|bz2|tbz|mp3|ogg)$") {
            # No point in compressing these
            unset req.http.Accept-Encoding;
        } elsif (req.http.Accept-Encoding ~ "gzip") {
            set req.http.Accept-Encoding = "gzip";
        } elsif (req.http.Accept-Encoding ~ "deflate") {
            set req.http.Accept-Encoding = "deflate";
        } else {
            # unknown algorithm
            unset req.http.Accept-Encoding;
        }
    }

    if (req.method == "PRI") {
        /* We do not support SPDY or HTTP/2.0 */
        return (synth(405));
    }

    if (!req.http.host &&
        req.esi_level == 0 &&
        req.proto ~ "^(?i)HTTP/1.1") {
        /* In HTTP/1.1, Host is required. */
        return (synth(400));
    }

    if (req.method != "GET" &&
        req.method != "HEAD" &&
        req.method != "PUT" &&
        req.method != "POST" &&
        req.method != "TRACE" &&
        req.method != "OPTIONS" &&
        req.method != "DELETE" &&
        req.method != "PATCH") {
        /* Non-RFC2616 or CONNECT which is weird. */
        return (pipe);
    }

    # We only deal with GET and HEAD by default
    if (req.method != "GET" && req.method != "HEAD") {
        return (pass);
    }

    # Detect backend user by different cookies
    if (req.http.Cookie ~ "\bbe_typo_user=") {
        set req.http.X-Is-Backend-User-Authenticated = "true";
    } elseif (req.http.Cookie ~ "\bNeos_Session=") {
        set req.http.X-Is-Backend-User-Authenticated = "true";
    } else {
        unset req.http.X-Is-Backend-User-Authenticated;
    }

    # Purge varnish when force reloading the page and backend user is detected
    if (req.restarts == 0 && req.http.Cache-Control ~ "no-cache" && req.http.X-Is-Backend-User-Authenticated) {
        set req.http.X-Restart-After-Purge = 1;
        return (purge);
    }

    include "includes/recv.vcl";

    # TYPO3: Always pass EXT:solr indexing requests
    if (req.http.X-Tx-Solr-Iq && std.ip(req.http.X-Client-Ip, client.ip) ~ webserver) {
        return (pass);
    }

    # Don't cache for TYPO3, Neos backend
    if (req.url ~ "^/(typo3|neos|_token-login)(/.*)?$") {
        return (pass);
    }

    # TYPO3: Admin panel should work
    if (req.url ~ "TSFE_ADMIN_PANEL") {
        return (pass);
    }

    # video streaming must be in pipe to work
    if (req.url ~ "\.(?:mp4|webm)$") {
        return (pipe);
    }

    return (hash);
}


sub vcl_backend_response {
    set beresp.http.x-url = bereq.url;
    set beresp.http.x-host = bereq.http.host;

    # Allow 24d stale content, before an error 500/404 is thrown
    set beresp.grace = 24h;

    # Allow edgeside includes
    if (beresp.http.content-type ~ "text") {
        set beresp.do_esi = true;
    }

    include "includes/backend_response_pre_cookie_unset.vcl";

    # ESI requests returning an error should not return the error page (possibly containing esi tags in the error document)
    if (beresp.status >= 400 && bereq.http.X-Varnish-Esi-Level && std.integer(bereq.http.X-Varnish-Esi-Level, 0) > 0) {
        return (abandon);
    }

    # cache only successfully responses and 404s
    if (beresp.status != 200 && beresp.status != 404) {
        set beresp.http.X-Cacheable = "NO: server response with error";
        set beresp.ttl = 0s;
    }

    # Respect force-reload, and clear cache accordingly. This means that a ctrl-reload will actually purge
    # the cache for this URL with backend user.
    if (bereq.http.Cache-Control ~ "no-cache" && bereq.http.X-Is-Backend-User-Authenticated) {
        set beresp.http.X-Cacheable = "NO: force-reload with backend user";
        set beresp.ttl = 0s;
    }

    # Since we rely on backend to send the correct Cache-control headers, we do nothing except for removing the cache-control headers before output
    # Handle Cache-Control private/no-cache/no-store headers
    if (beresp.http.Cache-Control ~ "(?i:no-cache|no-store|private)") {
        set beresp.http.X-Cacheable = "NO: cache-control header is not public";
        set beresp.ttl = 0s;
    }

    # Make sure that we unset all cache headers, so the browser does not cache it for us!
    unset beresp.http.Cache-Control;
    unset beresp.http.Pragma;
    unset beresp.http.Expires;
    unset beresp.http.Last-Modified;
    unset beresp.http.ETag;

    if (!beresp.http.X-Cacheable) {
        set beresp.http.X-Cacheable = "NO";
        if (beresp.ttl > 0s) {
            set beresp.http.X-Cacheable = "YES";
        }
    }

    if (beresp.http.Set-Cookie) {
        set beresp.http.X-Cacheable = "NO: Set-Cookie header is present";
        set beresp.ttl = 0s;
    }

    # Set TTL as header for debugging
    set beresp.http.X-Cache-TTL = beresp.ttl;

    # Make sure a lot of requests to uncached pages do not yam too much
    if (beresp.ttl <= 0s) {
        set beresp.ttl = 10s;
        set beresp.http.Cache-Control = "private";
        set beresp.uncacheable = true;
    }

    # Don't cache file larger than 1MB
    if (beresp.http.Content-Length ~ "[0-9]{7,}") {
        set beresp.http.X-Cacheable = "NO: file too large";
        set beresp.ttl = 1w;
        set beresp.uncacheable = true;
    }

    return (deliver);
}

sub vcl_hash {
    include "includes/hash.vcl";
}

sub vcl_hit {
    include "includes/hit.vcl";
}

sub vcl_miss {
    include "includes/miss.vcl";
}

sub vcl_backend_fetch {
    include "includes/backend_fetch.vcl";
    if (bereq.method == "GET") {
        unset bereq.body;
    }

    # range requests may have response code 206 which are not handled properly by varnish
    if (bereq.http.Range) {
        unset bereq.http.Range;
    }
}

sub vcl_deliver {
    # For static files, the browser should always get Age: 0 to cache it as long as possible
    if (resp.http.X-Set-Age-Zero) {
        unset resp.http.X-Set-Age-Zero;

        # By definition we have a fresh object
        set resp.http.age = "0";
    }

    unset resp.http.x-url;
    unset resp.http.x-host;

    if (std.ip(req.http.X-Client-Ip, client.ip) !~ debug) {
        unset resp.http.X-Cacheable;
        unset resp.http.X-Cache-Tags;
        unset resp.http.X-Cache-TTL;
        unset resp.http.X-Is-Static-File;
        unset resp.http.X-Site;
        unset resp.http.xkey;
    } elseif (obj.hits > 0) {
        set resp.http.X-Cache = "HIT";
        set resp.http.X-Cache-Hits = obj.hits;
    } else {
        set resp.http.X-Cache = "MISS";
    }

    include "includes/deliver.vcl";
}

sub vcl_purge {
    if (req.http.X-Restart-After-Purge) {
        return (restart);
    }
}

sub vcl_backend_error {
    # ESI requests returning an error should not return the error page (possibly containing esi tags in the error document)
    if (bereq.http.X-Varnish-Esi-Level && std.integer(bereq.http.X-Varnish-Esi-Level, 0) > 0) {
        set beresp.http.Content-Type = "text/html; charset=utf-8";
        synthetic("");
        set beresp.ttl = 0s;
        return (deliver);
    }
}

sub vcl_synth {
    if (req.http.X-Varnish-Esi-Level && std.integer(req.http.X-Varnish-Esi-Level, 0) > 0) {
        set resp.http.Content-Type = "text/html; charset=utf-8";
        synthetic("");
        return (deliver);
    }

    include "includes/synth.vcl";
}
